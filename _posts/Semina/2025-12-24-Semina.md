---
title: 12월 세미나
author: Chaewon Kim
date: 2025-12-23
category: Jekyll
layout: post
---


# 2025-12-24 (화) 

특이사항 : 첫 세미나 청취 

모르는 키워드 위주로 정리 시작 

어제 진행했던 세미나 간단하게 복기하기 

배경 키워드 

### Vector Search  
대규모 컬렉션에서 일반적으로 벡터로 표현되는 유사한 항목이나 데이터 포인트를 찾는 데 사용되는 검색 기술

벡터는 요소 간의 의미적 관계를 포착하여 머신 러닝 모델과 인공 지능 애플리케이션의 효과적인 처리를 가능하게 함

비유가 이해하기 쉬워서 가져옴 


전통적인 키워드 검색과 벡터 검색 간의 차이점을 설명하기 위해 예를 살펴보겠습니다. 최고의 피자 레스토랑에 대한 정보를 찾고 있고 전통적인 키워드 검색 엔진에서 "최고의 피자 레스토랑"을 검색한다고 가정합시다. 키워드 검색은 "최고의", "피자" 및 "레스토랑"이라는 정확한 단어가 포함된 페이지를 찾고 "최고의 피자 레스토랑" 또는 "내 주변 피자 레스토랑"과 같은 결과만 반환합니다. 전통적인 키워드 검색은 검색 이면의 맥락이나 의도를 이해하기보다는 **키워드를 일치시키는 데 중점**을 둡니다.

반면, 시맨틱 벡터 검색의 검색 엔진은 **쿼리 이면의 의도**를 이해합니다. 

시맨틱(semantic)은 정의상 언어의 의미와 관련이 있으며 시맨틱 검색은 쿼리의 의미와 맥락을 이해합니다. 그래서 콘텐츠에 "최고의 피자 레스토랑"이라는 정확한 단어가 사용되지 않았어도 최고 평점 또는 추천이 많은 피자 가게에 대해 이야기하는 콘텐츠를 찾습니다. 맥락과 관련성이 더 큰 결과를 제공하며 다양한 위치에 있는 고품질 피자 가게에 대해 설명하는 기사나 가이드를 포함할 수 있습니다.

![image](../assets/Semina/2025-12-23/vector_search.png)


출처 : https://www.ibm.com/kr-ko/think/topics/vector-search 


#### ANN (근사 최근접 이웃)
ANN 알고리즘은 정확한 일치를 찾는 것이 아니라 유클리드 거리 또는 코사인 유사성과 같은 일부 거리 메트릭을 기반으로 지정된 쿼리에 거의 가장 가까운 벡터를 효율적으로 검색합니다. 
이러한 알고리즘은 일정 수준의 근사치를 허용하므로 전체 코퍼스에서 임베딩 유사성을 계산할 필요 없이 최근접 이웃 검색의 계산 비용을 크게 줄일 수 있습니다.


논문 키워드 (솔직히 잘 몰라서 제미나이 도움 받음 )

dataset이 billion scale인 상황에서 searching 시 Query성능은 유지하면서 latency를 낮추는 것을 목표 


**DiskANN(Graph base) vs SPANN(Cluster base)**

    두 알고리즘 모두 메모리 제약을 극복하고 디스크에서 Billion-scale 데이터를 검색하기 위해 설계되었습니다.

    DiskANN (Graph-based): * 핵심: Vamana라는 강력한 그래프 인덱스를 사용합니다.

        특징: 데이터 간의 연결 관계(Edge)를 따라가며 검색합니다. SSD의 병렬 읽기 성능을 극대화하여, 적은 메모리로도 메모리 기반 알고리즘에 근접하는 높은 재현율(Recall)과 낮은 지연시간(Latency)을 보여줍니다.

    SPANN (Cluster-based): * 핵심: 데이터를 여러 개의 클러스터로 나누고, 각 클러스터의 중심점(Centroid)만 메모리에 올립니다.

        특징: 쿼리가 들어오면 가까운 클러스터들을 찾고, 해당 클러스터가 저장된 디스크 블록만 읽습니다. 그래프 방식보다 구조가 단순하며 특정 조건에서 더 빠른 검색 속도를 보여주기도 합니다.



Billion-scale 검색 시스템의 병목 현상을 해결하기 위한 프로토콜

**LIAR Protocol(Low-latency In-memory Adaptive Rescoring)**

    디스크에서 읽어온 후보군들을 메모리에서 다시 계산(Rescoring)할 때, 성능에 맞춰 적응적으로 처리하는 방식입니다. 불필요한 계산을 줄여 쿼리 응답 속도를 최적화합니다.    

**NAP(Neighbor-Aware Prefetching)**

    그래프 검색 시 다음에 방문할 가능성이 높은 이웃 노드들을 미리 예측해서 디스크에서 메모리로 가져오는(Prefetching) 기술입니다. 디스크 I/O 대기 시간을 줄여 Latency를 획기적으로 낮춥니다.

**local rebuilder**


데이터가 실시간으로 추가/수정될 때 인덱스를 어떻게 유지할 것인가에 대한 내용입니다.

**Out of place update vs In place update**

    In-place: 기존 데이터가 저장된 위치에 그대로 덮어쓰는 방식입니다. 공간 효율은 좋지만, 수정 중에 검색 성능이 떨어지거나 데이터가 깨질 위험이 있습니다.

    Out-of-place: 기존 데이터는 두고 새로운 위치에 데이터를 쓴 뒤 포인터를 바꿉니다. 안정적이고 Append-only 구조에 적합합니다.

**append only**

    데이터를 수정하거나 삭제하지 않고 무조건 뒤에 덧붙이는 방식입니다. 
    쓰기 성능이 매우 빠르고 로그 구조 저장소(LSM-tree 등)에서 자주 쓰이며, 검색 시에는 최신 버전만 참조합니다.

**NNS(Nearest Neighbor Search)**

    고차원 공간에서 특정 쿼리 벡터와 가장 유사한(거리가 가까운) 데이터를 찾는 근본적인 문제

**요약 : 데이터 변경 시 벡터값 생성 -> 위치 이동 -> 주변 이웃/클러스터 재설정 과정이 필요하며, 이 작업을 시스템 성능 저하 없이 실시간으로 처리하는 것이 이 분야의 핵심 기술**



키워드 정리

    파일 시스템은 갑작스러운 전원 차단 시 데이터가 깨지는 것을 막기 위해 여러 장치를 둡니다.

**Jounaling**

    데이터를 실제로 저장하기 전에, "어떤 작업을 할 것인지"에 대한 로그(Journal)를 먼저 남기는 방식입니다. 사고가 나도 이 로그를 보고 복구할 수 있습니다.

**transcaction**

    여러 개의 작업(파일 생성, 크기 수정, 시간 업데이트 등)을 하나의 묶음으로 처리하는 단위입니다. "모두 성공하거나, 아니면 아예 하나도 안 한 상태로 되돌리거나(All or Nothing)"를 보장합니다.

**transcation lock up**

    저널링 과정에서 너무 많은 트랜잭션이 한꺼번에 몰리거나, 특정 작업이 길어지면서 전체 시스템이 일시적으로 멈추는(Freezing) 현상

**CXL memory**

    CPU와 메모리, 저장장치를 더 빠르게 연결하는 차세대 인터페이스입니다.

**built in cache**

    파일 시스템 내부에 구현된 캐시 영역입니다. 자주 사용하는 메타데이터나 데이터를 메모리에 상주시켜 디스크 I/O를 최소화합니다.

**DJFS(Decoupled Journaling File System)**

    전통적인 파일 시스템은 데이터와 저널을 같은 장치에 쓰는데, DJFS는 이 **저널링 과정을 분리(Decoupled)**하여 최적화한 파일 시스템입니다.

    보통 비휘발성 메모리(NVM)나 CXL 메모리에 저널만 따로 저장해 성능을 극대화하는 논문 등에서 자주 등장하는 개념입니다.


**commit**

    트랜잭션 작업이 성공적으로 완료되어 변경 사항을 파일 시스템에 영구적으로 반영하는 최종 단계입니다.

**shadow copy**

    원본 데이터를 직접 수정하지 않고, 복사본을 만들어 수정하는 방식입니다. 작업 중에 문제가 생겨도 원본은 안전하며, 스냅샷(Snapshot) 기능을 구현할 때 핵심입니다.

**CMM-H(CXL Memory Module - Hybrid)**

    기존의 저장 장치는 'DRAM(매우 빠름, 용량 작음)'과 'SSD(느림, 용량 큼)'로 완전히 분리되어 있었습니다. CMM-H는 이 둘을 하나의 CXL 장치 안에 합친 하이브리드 모델입니다.

    구조: 장치 내부에 DRAM 캐시 + **NAND 플래시(SSD)**가 같이 들어있습니다.

    특징: Near-DRAM 성능: 자주 쓰는 데이터는 내부 DRAM 캐시에서 처리해 DRAM급 속도를 냅니다.

        NAND급 용량: 실제 데이터는 NAND에 저장하므로 테라바이트(TB) 단위의 대용량을 제공합니다.

        Persistence (비휘발성): 전원이 꺼져도 배터리 등을 이용해 DRAM의 데이터를 NAND로 옮겨 보존합니다.


# 2025-12-30 (화) 

처음 들어보는 키워드 위주로 정리하기 


**Phony Buffer**
리눅스 커널이 GPU 메모리로 직접 I/O를 수행할 때, 이를 시스템 메모리처럼 인식하게 만들기 위해 생성하는 가짜 구조체(struct page)로, 성능 저하의 원인이 됨.


**GDS**
CPU와 시스템 메모리를 거치지 않고, NVMe 스토리지에서 GPU 메모리로 데이터를 직접 전송하여 대역폭을 높이는 기술.


**Phoenix**
기존 GDS의 오버헤드(Phony Buffer)를 제거하고 I/O 경로를 최적화하여 지연 시간을 줄인 새로운 I/O 스택.


**Zone device**
GPU 메모리와 같은 장치 메모리를 CPU의 페이지 테이블에 직접 매핑하여, 커널이 이를 일반 메모리처럼 관리할 수 있게 해주는 리눅스 기능.


**POSIX API**
read, write 같은 표준 파일 입출력 인터페이스로, Phoenix는 이를 준수하여 기존 코드 수정 없이 고성능 I/O를 사용할 수 있게 함.


**KV cache**
대규모 언어 모델(LLM) 추론 시 중복 연산을 방지하기 위해 저장하는 이전 토큰들의 연산 결과값.


**IO stack latency**
운영체제 커널, 파일 시스템, 드라이버 등 소프트웨어 계층을 데이터가 통과하는 데 걸리는 지연 시간.

