---
title: ROS2 DDS 성능 차이 분석
author: Chaewon Kim
date: 2026-01-02
category: Jekyll
layout: post
---


# Nav2 구동 시 DDS별 시스템 리소스 비교 분석

## 서론 

### 실험 목적
- ROS 2 기본 미들웨어인 Fast DDS와 대안인 Cyclone DDS 중, 내 환경(32-core 고사양 워크스테이션)에서 누가 더 효율적인지 확인.

- 단순 통신이 아닌, 무거운 Nav2(자율주행) 스택을 돌릴 때 실제 CPU 부하와 스레드 스위칭(Context Switch) 차이를 검증함.

### 실험 환경
- H/W: 32-Core Workstation

- S/W: Ubuntu 22.04 (ROS 2 Humble), Nav2, Gazebo

- 비교군:

    rmw_fastrtps_cpp (Fast DDS - 기본값)

    rmw_cyclonedds_cpp (Cyclone DDS)

### 측정 방법
- 통제 변수: 스크립트를 사용하여 로봇 초기 위치와 목표 지점을 100% 동일하게 설정.

- 측정 지표: pidstat을 이용한 CPU 사용률(%usr, %sys), 메모리, Context Switch 횟수.

### 가설
- 32코어 환경에서는 DDS의 스레드 처리 방식에 따라 커널 오버헤드(System Time) 차이가 발생할 것이다.

### 실험 과정 
Step 1. 환경 초기화 & Gazebo 실행 (Terminal 1)

Step 2. Nav2 스택 실행 (Terminal 2)

Step 3. 실험 수행 (Terminal 3,4)

Step 4. 프로세스 완전 종료

```
# 경로 및 명령어 정리

export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp

ros2 daemon stop; ros2 daemon start

~/nav_ws/Exp/gaze_test$ ./gaze.sh

~/nav_ws/Exp/gaze_test$ ./nav.sh

~/nav_ws/Exp/test_DDS$ ./run_mission.sh

~/nav_ws/Exp/test_DDS$ ./monitor.sh

./monitor_only.sh cyclone & sleep 2; ./run_mission.sh

pkill -9 -f ros2
pkill -9 -f nav2
pkill -9 -f gzserver
pkill -9 -f gzclient
```

## 명령어


#현재 DDS 확인 
```
ros2 doctor --report | grep middleware
```

Fast DDS일 때: middleware name    : rmw_fastrtps_cpp

Cyclone DDS일 때: middleware name    : rmw_cyclonedds_cpp


갱신하기 위해 설정 초기화 진행 
```
# DDS 변경 후 필수 코스
ros2 daemon stop
ros2 daemon start
```





### 실험 데이터 모아둔 곳 
https://docs.google.com/spreadsheets/d/10NJ4Rm9oHbsgZX_uwaOSO2NtIowHm0w2CY9T8_2BCNw/edit?usp=sharing

데이터 의미

1. 🖥️ CPU (가장 오른쪽) - 여기가 메인 무대

프로세서가 시간을 어디에 쓰고 있는지 보여줍니다.

    us (User Time): 사용자 영역.

        ROS 2 노드(Nav2, Gazebo 등)가 실제로 일하는 시간입니다.

    sy (System Time) ⭐: 커널 영역.

        DDS 실험의 핵심입니다. OS가 하드웨어를 제어하거나 프로세스 간 통신(DDS)을 중재하는 데 쓴 시간입니다. Cyclone vs Fast DDS 중 누가 더 '가볍냐'를 볼 때 sy가 낮은 게 좋습니다.

    id (Idle): 휴식.

        CPU가 놀고 있는 비율입니다. (님 컴퓨터는 32코어라 여기가 90% 이상인 게 정상)

    wa (Wait I/O): 대기.

        하드디스크나 네트워크 응답을 기다리느라 멍 때리는 시간입니다.

    st (Stolen): 가로채기.

        가상 머신 환경에서 호스트 OS에게 뺏긴 시간(보통 0).

2. ⚙️ System (중간) - 이번 실험의 승부처

운영체제의 부하를 보여줍니다.

    in (Interrupts): 인터럽트.

        하드웨어(키보드, 마우스, 네트워크 카드)가 CPU를 "잠깐 나 좀 봐줘!" 하고 부른 횟수입니다.

    cs (Context Switches) ⭐⭐⭐: 문맥 교환.

        이번 실험에서 가장 중요합니다.

        CPU가 A작업을 하다가 B작업으로 갈아탄 횟수입니다.

        ROS 2는 수많은 노드(스레드)가 통신하므로, 이 숫자가 낮을수록 효율적인 미들웨어입니다. (아까 7만까지 튀었던 그 녀석입니다.)

3. 🚀 Procs (가장 왼쪽) - 프로세스 상태

    r (Running): 실행 중.

        현재 CPU를 쓰고 있거나, 쓰려고 줄 서 있는 프로세스 개수입니다. 코어 수(32)보다 낮으면 아주 쾌적한 겁니다.

    b (Blocked): 멈춤.

        메모리나 디스크 입출력을 기다리느라 잠들어 있는 프로세스입니다.

4. 💾 Memory & Swap (중간 왼쪽)

    swpd: 가상 메모리 사용량 (0이 좋음).

    free: 남은 램 용량.

    buff: 버퍼 메모리.

    cache: 캐시 메모리 (리눅스는 남는 램을 캐시로 써서, 여기가 높고 free가 낮아도 정상입니다).

    si / so (Swap In/Out):

        램이 부족해서 하드디스크를 램처럼 쓴 횟수. 여기가 0이 아니면 컴퓨터가 비명 지르는 중인 겁니다. (다행히 로그에선 0입니다.)

5. 💿 IO (입출력)

    bi (Blocks In): 디스크에서 읽어온 데이터 양.

    bo (Blocks Out): 디스크에 쓴 데이터 양 (로그 파일 저장할 때 수치가 올라갑니다).

    
💡 요약: 님 실험에서 봐야 할 것

딱 3가지만 기억하세요.

    cs (Context Switch): 낮을수록 좋다. (DDS 효율성 직결)

    sy (System CPU): 낮을수록 좋다. (오버헤드)

    us (User CPU): 비슷하거나 낮을수록 좋다. (연산 효율)