---
title: ROS2 DDS 성능 차이 분석
author: Chaewon Kim
date: 2026-01-02
category: Jekyll
layout: post
---


# Nav2 구동 시 DDS별 시스템 리소스 비교 분석

## 서론 

### 실험 목적
- ROS 2 기본 미들웨어인 Fast DDS와 대안인 Cyclone DDS 중, 내 환경(32-core 고사양 워크스테이션)에서 누가 더 효율적인지 확인.

- 단순 통신이 아닌, 무거운 Nav2(자율주행) 스택을 돌릴 때 실제 CPU 부하와 스레드 스위칭(Context Switch) 차이를 검증함.

### 실험 환경
- H/W: 32-Core Workstation

- S/W: Ubuntu 22.04 (ROS 2 Humble), Nav2, Gazebo

- 비교군:

    rmw_fastrtps_cpp (Fast DDS - 기본값)

    rmw_cyclonedds_cpp (Cyclone DDS)

### 측정 방법
- 통제 변수: 스크립트를 사용하여 로봇 초기 위치와 목표 지점을 100% 동일하게 설정.

- 측정 지표: pidstat을 이용한 CPU 사용률(%usr, %sys), 메모리, Context Switch 횟수.

### 가설
- 32코어 환경에서는 DDS의 스레드 처리 방식에 따라 커널 오버헤드(System Time) 차이가 발생할 것이다.

### 실험 과정 
Step 1. 환경 초기화 & Gazebo 실행 (Terminal 1)

Step 2. Nav2 스택 실행 (Terminal 2)

Step 3. 실험 수행 (Terminal 3,4)

Step 4. 프로세스 완전 종료

```
# 경로 및 명령어 정리

export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp

ros2 daemon stop; ros2 daemon start

~/nav_ws/Exp/gaze_test$ ./gaze.sh

~/nav_ws/Exp/gaze_test$ ./nav.sh

~/nav_ws/Exp/test_DDS$ ./run_mission.sh

~/nav_ws/Exp/test_DDS$ ./monitor.sh

./monitor_only.sh cyclone & sleep 2; ./run_mission.sh

pkill -9 -f ros2
pkill -9 -f nav2
pkill -9 -f gzserver
pkill -9 -f gzclient


✅ 올바른 순서 (이대로만 하세요)

    설정 선언 (export): "나 이제부터 Cyclone DDS 쓸 거야!" 라고 컴퓨터에 알림.

    데몬 정지 (stop): "옛날 설정으로 돌고 있던 데몬 꺼져!"

    데몬 시작 (start): "방금 내가 말한 설정(Cyclone)으로 다시 태어나라!"

```

## 명령어


#현재 DDS 확인 
```
ros2 doctor --report | grep middleware
```

Fast DDS일 때: middleware name    : rmw_fastrtps_cpp

Cyclone DDS일 때: middleware name    : rmw_cyclonedds_cpp


갱신하기 위해 설정 초기화 진행 
```
# DDS 변경 후 필수 코스
ros2 daemon stop
ros2 daemon start
```





### 실험 데이터 모아둔 곳 
https://docs.google.com/spreadsheets/d/10NJ4Rm9oHbsgZX_uwaOSO2NtIowHm0w2CY9T8_2BCNw/edit?usp=sharing


32코어라 유의미한 차이가 보이지 않음

-> 4코어로 줄여버리기 

```
taskset -c 0-3 ros2 launch nav2_bringup tb3_simulation_launch.py ...

taskset -c 0-3 ./run_mission.sh
```



데이터 의미

1. 🖥️ CPU (가장 오른쪽) - 여기가 메인 무대

프로세서가 시간을 어디에 쓰고 있는지 보여줍니다.

    us (User Time): 사용자 영역.

        ROS 2 노드(Nav2, Gazebo 등)가 실제로 일하는 시간입니다.

    sy (System Time) ⭐: 커널 영역.

        DDS 실험의 핵심입니다. OS가 하드웨어를 제어하거나 프로세스 간 통신(DDS)을 중재하는 데 쓴 시간입니다. Cyclone vs Fast DDS 중 누가 더 '가볍냐'를 볼 때 sy가 낮은 게 좋습니다.

    id (Idle): 휴식.

        CPU가 놀고 있는 비율입니다. (님 컴퓨터는 32코어라 여기가 90% 이상인 게 정상)

    wa (Wait I/O): 대기.

        하드디스크나 네트워크 응답을 기다리느라 멍 때리는 시간입니다.

    st (Stolen): 가로채기.

        가상 머신 환경에서 호스트 OS에게 뺏긴 시간(보통 0).

2. ⚙️ System (중간) - 이번 실험의 승부처

운영체제의 부하를 보여줍니다.

    in (Interrupts): 인터럽트.

        하드웨어(키보드, 마우스, 네트워크 카드)가 CPU를 "잠깐 나 좀 봐줘!" 하고 부른 횟수입니다.

    cs (Context Switches) ⭐⭐⭐: 문맥 교환.

        이번 실험에서 가장 중요합니다.

        CPU가 A작업을 하다가 B작업으로 갈아탄 횟수입니다.

        ROS 2는 수많은 노드(스레드)가 통신하므로, 이 숫자가 낮을수록 효율적인 미들웨어입니다. (아까 7만까지 튀었던 그 녀석입니다.)

3. 🚀 Procs (가장 왼쪽) - 프로세스 상태

    r (Running): 실행 중.

        현재 CPU를 쓰고 있거나, 쓰려고 줄 서 있는 프로세스 개수입니다. 코어 수(32)보다 낮으면 아주 쾌적한 겁니다.

    b (Blocked): 멈춤.

        메모리나 디스크 입출력을 기다리느라 잠들어 있는 프로세스입니다.

4. 💾 Memory & Swap (중간 왼쪽)

    swpd: 가상 메모리 사용량 (0이 좋음).

    free: 남은 램 용량.

    buff: 버퍼 메모리.

    cache: 캐시 메모리 (리눅스는 남는 램을 캐시로 써서, 여기가 높고 free가 낮아도 정상입니다).

    si / so (Swap In/Out):

        램이 부족해서 하드디스크를 램처럼 쓴 횟수. 여기가 0이 아니면 컴퓨터가 비명 지르는 중인 겁니다. (다행히 로그에선 0입니다.)

5. 💿 IO (입출력)

    bi (Blocks In): 디스크에서 읽어온 데이터 양.

    bo (Blocks Out): 디스크에 쓴 데이터 양 (로그 파일 저장할 때 수치가 올라갑니다).

    
💡 요약: 님 실험에서 봐야 할 것

딱 3가지만 기억하세요.

    cs (Context Switch): 낮을수록 좋다. (DDS 효율성 직결)

    sy (System CPU): 낮을수록 좋다. (오버헤드)

    us (User CPU): 비슷하거나 낮을수록 좋다. (연산 효율)


# 실험 다시 설계 (0105)

- 초안 계속 작성 中

- 깐깐한 교수님 컨셉 제미나이와 함께 쓰는 초안 & 고민거리 정리 


32코어 환경에서는 그래프가 시각적으로 큰 차이가 나지 않아 gazebo와 nav2를 4코어로만 연산하도록 강제한다. 
또 로봇이 1회 움직이는 것 만으로는 해당 로봇이 어느 순간에 연산이 증가하는지 알 수 없어 총 3번을 이동하도록 스크립트를 작성한다 .

----
논문 느낌으로 어투 바꾸기 (지금부터라도 연습하자.)
- 그래프가 차이가 안나서 → 변별력이 낮아, 시스템 부하 증감 패턴을 파악하기 어려우므로, 유의미한 차이를 관측하기 어려워
- 알 수 없어 → 파악하기 어려우므로
- 어느 순간에 연산이 증가하는지 → 부하(Load)의 증감 패턴, 리소스 점유율 변화 
- 강제한다 → 제한하였다, 할당하였다
- 차이를 보고싶어서 → 부하를 구분하기 위해, 연산 패턴의 차이를 규명하고자
- 도착 순간 → 목표점 도달(Goal Reaching), 도착 시점 
- Ilde한 순간 → 대기(Idle), 정적 상태 (Static State)

영어 논문만 읽지 말고 국문도 읽으면서 어휘력 길러야겠다.
----

 32 코어 환경에서는 성능 지표의 **변별력이 낮아**, Gazebo와 Nav2의 연산 자원을 4코어로 제한하였다. 또한 주행, 대기, 목표점 도달 등 로봇의 상태 변화에 따른 시스템 부하를 명확히 구분하기 위해 삼각형 궤적을 그리며 출발지로 회귀하는 시나리오를 구성하였다. 

- 그럼 위의 과정을 왜 실험하느냐? 
fast DDS와 cyclone DDS의 차이를 보고 싶어서. 

왜 


## 실험의 최종 목적 
본 실험은 ROS 2의 주요 미들웨어인 Fast DDS와 Cyclone DDS의 시스템 부하 특성을 비교 분석하는 데 목적이 있다. 32코어 환경에서는 미들웨어 간 성능 지표의 변별력이 낮아 Gazebo와 Nav2의 자원을 4코어로 제한하였으며, 주행(Motion), 대기(Idle), 도착(Arrival) 등 로봇의 상태 변화에 따른 DDS별 리소스 점유율 추이를 파악하기 위해 삼각 궤적의 왕복 시나리오를 적용하였다.


- 이 실험이 왜 의미있을까? (Contribution(의의), Implication(시사점))
  


---

### 제미나이의 지적: 

- Idle의 정의가 무엇일까? 
바퀴는 멈춰잇어도 lidar랑 amcl, local costmap은 계속 업데이트 되고 있는데 이게 과연 진짜 idle한 상태일까? 
용어를 재정의할 필요성이 있다. 
센서 데이터 퍼블리싱을 유지할지, 끄는지 등등
**실험 조건 명확하게 명시 필요**


- 결론이 너무 뻔함
더 깊게 파게: "CPU 사용량이 10% 줄어들면 배터리 수명이 대략 몇 분 늘어날 것으로 추산된다"라거나, "메시지 드랍율(Drop rate)이 특정 구간에서 급증하는 임계점이 어디다" 같은 **구체적인 수치(Quantitative Insight)**를 내놓게



[자네가 지금 당장 해야 할 일]

    'Idle' 상태일 때 정확히 어떤 토픽들이 오가고 있는지 리스트업 해오게. (진짜 데이터가 없는 건지, Discovery 패킷만 치는 건지 알아야 할 것 아닌가.)

    iRobot 리포트랑 Maruyama 논문 찾아서 읽고, 자네 실험이 그들보다 **'더 나은 점'**이 뭔지 한 문장으로 가져오게.



'이 정도의 손해(Trade-off)를 감수하고서라도 바꿀 가치가 있는지' 증명


Cyclone으로 바꿨더니 Idle 시 CPU 점유율이 5% 떨어졌고, 이는 이론상 배터리 수명을 30분 연장하는 효과가 있다' 처럼 구체적인 이득(Benefit)을 제시해야지


궁금해서 해봤다? 그건 초등학생 일기장에나 쓰는 말일세."

"자네, 방금 'DDS에 따라 부하가 어떻게 다른지 알고 싶어서', 'Fast DDS가 디폴트인 이유가 있겠지만 다른 것도 궁금해서'라고 했나? 연구는 '궁금증 해결'이 아니라 **'가설 검증(Hypothesis Verification)'**이어야 해.

"Cyclone은 멈춰 있을 때 왜 조용한가? Fast DDS는 왜 시끄러운가? 멀티캐스트(Multicast) 폭주 문제인가, 아니면 공유 메모리(Shared Memory) 설정 이슈인가? 원인 분석 없이 결과 그래프만 띡 보여주면서 'A가 낮네요'라고 하는 건 엔지니어가 아니라 단순 측정 아르바이트나 하는 일이야. **'정지 상태에서의 Discovery 트래픽 차이'**를 언급하지 않을 거면 이 파트는 빼게."

지적: "그건 구글 검색하면 10초 만에 나와. iRobot이 이미 2021년에 다 밝혀냈어. 자네는 남들이 다 해놓은 밥상에 숟가락만 얹겠다는 건가? Nav2 환경에서 실험한다고 했지? 그럼 적어도 '단순 통신 테스트에서는 안 보이던 문제가, 무거운 Nav2 스택과 결합될 때 어떤 비선형적인 부하(Non-linear Overhead)를 만들어내는지' 보여줘야 할 거 아닌가!"




----


## 여러 논문 읽으면서 쓸만한 내용 건지기

- Exploring the Performance of ROS2 (2016)
아 잠만, 2016이 10년전이라고? 

however, this(DDS) incurs additional overhead, which is examined in this study

Transport latencies between ROS2 nodes vary depending on the use cases, data size, configurations, and DDS vendors

측정한 요소들 : latency, throughput, the number of threads, memory consumbtion
변수 : DDS, Qos Policies

evalutate end-to-end latencies for publish/subscribe message

we sould use a different DDS implementation for different situations

여기서는 ROS1 과 ROS2 성능 비교도 진행함 